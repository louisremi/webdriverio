<head>
    <title>DEMO APP</title>
    <style>
        [id^="overflow"] {
            width: 100px;
            height: 100px;
            background-color: black;
        }

        #overflow {
            overflow: hidden;
        }

        #overflow-x {
            overflow-x: hidden;
        }

        #overflow-y {
            overflow-y: hidden;
        }

        #overflow-0w {
            overflow: hidden;
            width: 0px;
        }

        #overflow-0h {
            overflow: hidden;
            height: 0px;
        }

        #overflow-x-0w {
            overflow-x: hidden;
            width: 0px;
        }

        #overflow-y-0h {
            overflow-y: hidden;
            height: 0px;
        }
    </style>
</head>

<body>
    <main>
        <h2><code>{ overflow: hidden; width: 100; height: 100; }</code></h2>
        <div id="overflow">overflow: hidden</div>
        <h2><code>{ overflow-x: hidden; width: 100; height: 100; }</code></h2>
        <div id="overflow-x">overflow: hidden</div>
        <h2><code>{ overflow-y: hidden; width: 100; height: 100; }</code></h2>
        <div id="overflow-y">overflow: hidden</div>
        <h2><code>{ overflow: hidden; width: 0 }</code></h2>
        <div id="overflow-0w">overflow: hidden</div>
        <h2><code>{ overflow: hidden; height: 0 }</code></h2>
        <div id="overflow-0h">overflow: hidden</div>
        <h2><code>{ overflow-x: hidden; width: 0 }</code></h2>
        <div id="overflow-x-0w">overflow-x: hidden</div>
        <h2><code>{ overflow-y: hidden; height: 0 }</code></h2>
        <div id="overflow-y-0h">overflow-y: hidden</div>
    </main>

    <script>
        function isElementDisplayed(element) {
            function nodeIsElement(node) {
                if (!node) {
                    return false;
                }
                switch (node.nodeType) {
                    case Node.ELEMENT_NODE:
                    case Node.DOCUMENT_NODE:
                    case Node.DOCUMENT_FRAGMENT_NODE:
                        return true;
                    default:
                        return false;
                }
            }
            function parentElementForElement(element) {
                if (!element) {
                    return null;
                }
                return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);
            }
            function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {
                for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {
                    if (predicate(node)) {
                        return node;
                    }
                }
                return null;
            }
            function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {
                for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {
                    if (predicate(element)) {
                        return element;
                    }
                }
                return null;
            }
            function cascadedStylePropertyForElement(element, property) {
                if (!element || !property) {
                    return null;
                }
                // if document-fragment, skip it and use element.host instead. This happens
                // when the element is inside a shadow root.
                // window.getComputedStyle errors on document-fragment.
                if ("ShadowRoot" in window && element instanceof window.ShadowRoot) {
                    element = element.host;
                }
                const computedStyle = window.getComputedStyle(element);
                const computedStyleProperty = computedStyle.getPropertyValue(property);
                if (computedStyleProperty && computedStyleProperty !== "inherit") {
                    return computedStyleProperty;
                }
                // Ideally getPropertyValue would return the 'used' or 'actual' value, but
                // it doesn't for legacy reasons. So we need to do our own poor man's cascade.
                // Fall back to the first non-'inherit' value found in an ancestor.
                // In any case, getPropertyValue will not return 'initial'.
                // FIXME: will this incorrectly inherit non-inheritable CSS properties?
                // I think all important non-inheritable properties (width, height, etc.)
                // for our purposes here are specially resolved, so this may not be an issue.
                // Specification is here: https://drafts.csswg.org/cssom/#resolved-values
                const parentElement = parentElementForElement(element);
                return cascadedStylePropertyForElement(parentElement, property);
            }
            // function elementHasBoundingBox(element: Element): boolean {
            //     const boundingBox = element.getBoundingClientRect()
            //     return boundingBox.width > 0 && boundingBox.height > 0
            // }
            function elementSubtreeHasNonZeroDimension({ element, dimension, }) {
                const boundingBox = element.getBoundingClientRect();
                console.log({ boundingBox });
                if (boundingBox.width > 0 && boundingBox.height > 0) {
                    return true;
                }
                // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.
                if (element.tagName.toUpperCase() === "PATH" &&
                    (boundingBox.width > 0 || boundingBox.height > 0)) {
                    const strokeWidth = cascadedStylePropertyForElement(element, "stroke-width");
                    return !!strokeWidth && Number(strokeWidth) > 0;
                }
                const cascadedOverflow = cascadedStylePropertyForElement(element, `overflow-${dimension}`);
                console.log({ cascadedOverflow });
                if (cascadedOverflow === "hidden" &&
                    (dimension === "x" ? boundingBox.width : boundingBox.height) === 0) {
                    return false;
                }
                // If the container's overflow is not hidden and it has zero size, consider the
                // container to have non-zero dimensions if a child node has non-zero dimensions.
                return [].some.call(element.childNodes, function (childNode) {
                    if (childNode.nodeType === Node.TEXT_NODE) {
                        return true;
                    }
                    if (nodeIsElement(childNode)) {
                        return elementSubtreeHasNonZeroDimension({
                            element: childNode,
                            dimension,
                        });
                    }
                    return false;
                });
            }
            // function elementOverflowsContainerOnDimension({ element, dimension }: {element: Element, dimension: 'x' | 'y'}) {
            //     const cascadedOverflow = cascadedStylePropertyForElement(element, `overflow-${dimension}`)
            //     if (cascadedOverflow !== 'hidden') {
            //         return false
            //     }
            //     // FIXME: this needs to take into account the scroll position of the element,
            //     // the display modes of it and its ancestors, and the container it overflows.
            //     // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.
            //     return true
            // }
            // function isElementSubtreeHiddenByOverflow(element: Element): boolean {
            //     const boundingBox = element.getBoundingClientRect()
            //     if (boundingBox.width === 0 && isElementSubtreeHiddenByOverflowOnDimension({ element, dimension: 'x' })) {
            //         return true
            //     }
            //     if (boundingBox.height === 0 && isElementSubtreeHiddenByOverflowOnDimension({ element, dimension: 'y' })) {
            //         return true
            //     }
            //     return false
            // }
            // function isElementSubtreeHiddenByOverflowOnDimension({ element, dimension }: {element: Element, dimension: 'x' | 'y'}): boolean {
            //     if (!element) {
            //         return false
            //     }
            //     // TODO: this becomes redundant once we start recursing in the children of the original element
            //     if (!elementOverflowsContainerOnDimension({ element, dimension })) {
            //         return false
            //     }
            //     if (!element.childNodes.length) {
            //         return false
            //     }
            //     // This element's subtree is hidden by overflow if all child subtrees are as well.
            //     return [].every.call(element.childNodes, function (childNode: Element) {
            //         // Returns true if the child node is overflowed or otherwise hidden.
            //         // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.
            //         // Visibility of text nodes is controlled by parent
            //         // TODO: Move three following ifs up to the parent function
            //         if (childNode.nodeType === Node.TEXT_NODE) {
            //             return false
            //         }
            //         if (!nodeIsElement(childNode)) {
            //             return true
            //         }
            //         if (!elementSubtreeHasNonZeroDimension({ element: childNode, dimension })) {
            //             return true
            //         }
            //         // END TODO
            //         // Recurse.
            //         return isElementSubtreeHiddenByOverflowOnDimension({ element: childNode, dimension })
            //     })
            // }
            // walk up the tree testing for a shadow root
            function isElementInsideShadowRoot(element) {
                if (!element) {
                    return false;
                }
                if (element.parentNode && element.parentNode.host) {
                    return true;
                }
                return isElementInsideShadowRoot(element.parentNode);
            }
            // This is a partial reimplementation of Selenium's "element is displayed" algorithm.
            // When the W3C specification's algorithm stabilizes, we should implement that.
            // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.
            if (!isElementInsideShadowRoot(element) &&
                // IE doesn't support document.contains, therefor check before using
                (typeof document.contains === "function"
                    ? !document.contains(element)
                    : !document.body.contains(element))) {
                return false;
            }
            // Special cases for specific tag names.
            switch (element.tagName.toUpperCase()) {
                case "BODY":
                    return true;
                case "SCRIPT":
                case "NOSCRIPT":
                    return false;
                case "OPTGROUP":
                case "OPTION": {
                    // Option/optgroup are considered shown if the containing <select> is shown.
                    const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {
                        return e.tagName.toUpperCase() === "SELECT";
                    });
                    return isElementDisplayed(enclosingSelectElement);
                }
                case "INPUT":
                    // <input type="hidden"> is considered not shown.
                    if (element.type === "hidden") {
                        return false;
                    }
                    break;
                // case 'MAP':
                // FIXME: Selenium has special handling for <map> elements. We don't do anything now.
                default:
                    break;
            }
            if (cascadedStylePropertyForElement(element, "visibility") !== "visible") {
                return false;
            }
            console.log("Element is visible", element.id, element);
            // TODO: return false early if this test fails
            const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {
                return (Number(cascadedStylePropertyForElement(e, "opacity")) === 0);
            });
            const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {
                return cascadedStylePropertyForElement(e, "display") === "none";
            });
            if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {
                return false;
            }
            console.log("Element is not transparent or display none", element.id, element);
            if (!elementSubtreeHasNonZeroDimension({ element, dimension: "x" })) {
                console.log("Element has no x dimension", element.id, element);
                return false;
            }
            if (!elementSubtreeHasNonZeroDimension({ element, dimension: "y" })) {
                console.log("Element has no y dimension", element.id, element);
                return false;
            }
            // if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {
            //     return false
            // }
            return true;
        }
    </script>
</body>